-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module DB.Query exposing (AssetRequiredArguments, AssetsConnectionOptionalArguments, AssetsOptionalArguments, BlogPostRequiredArguments, BlogPostsConnectionOptionalArguments, BlogPostsOptionalArguments, ColorRequiredArguments, ColorsConnectionOptionalArguments, ColorsOptionalArguments, ContactRequiredArguments, ContactsConnectionOptionalArguments, ContactsOptionalArguments, LocationRequiredArguments, LocationsConnectionOptionalArguments, LocationsOptionalArguments, NodeRequiredArguments, ProjectRequiredArguments, ProjectsConnectionOptionalArguments, ProjectsOptionalArguments, asset, assets, assetsConnection, blogPost, blogPosts, blogPostsConnection, color, colors, colorsConnection, contact, contacts, contactsConnection, location, locations, locationsConnection, node, project, projects, projectsConnection)

import DB.Enum.AssetOrderByInput
import DB.Enum.BlogPostOrderByInput
import DB.Enum.ColorOrderByInput
import DB.Enum.ContactOrderByInput
import DB.Enum.LocationOrderByInput
import DB.Enum.ProjectOrderByInput
import DB.InputObject
import DB.Interface
import DB.Object
import DB.Scalar
import DB.ScalarDecoders
import Graphql.Internal.Builder.Argument as Argument
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode
import Graphql.Operation exposing (RootQuery)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


type alias AssetsOptionalArguments =
    { where_ : OptionalArgument DB.InputObject.AssetWhereInput
    , orderBy : OptionalArgument DB.Enum.AssetOrderByInput.AssetOrderByInput
    , skip : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-|

  - where\_ -

-}
assets : (AssetsOptionalArguments -> AssetsOptionalArguments) -> SelectionSet decodesTo DB.Object.Asset -> SelectionSet (List (Maybe decodesTo)) RootQuery
assets fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ DB.InputObject.encodeAssetWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum DB.Enum.AssetOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "assets" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


type alias ColorsOptionalArguments =
    { where_ : OptionalArgument DB.InputObject.ColorWhereInput
    , orderBy : OptionalArgument DB.Enum.ColorOrderByInput.ColorOrderByInput
    , skip : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-|

  - where\_ -

-}
colors : (ColorsOptionalArguments -> ColorsOptionalArguments) -> SelectionSet decodesTo DB.Object.Color -> SelectionSet (List (Maybe decodesTo)) RootQuery
colors fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ DB.InputObject.encodeColorWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum DB.Enum.ColorOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "colors" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


type alias LocationsOptionalArguments =
    { where_ : OptionalArgument DB.InputObject.LocationWhereInput
    , orderBy : OptionalArgument DB.Enum.LocationOrderByInput.LocationOrderByInput
    , skip : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-|

  - where\_ -

-}
locations : (LocationsOptionalArguments -> LocationsOptionalArguments) -> SelectionSet decodesTo DB.Object.Location -> SelectionSet (List (Maybe decodesTo)) RootQuery
locations fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ DB.InputObject.encodeLocationWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum DB.Enum.LocationOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "locations" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


type alias BlogPostsOptionalArguments =
    { where_ : OptionalArgument DB.InputObject.BlogPostWhereInput
    , orderBy : OptionalArgument DB.Enum.BlogPostOrderByInput.BlogPostOrderByInput
    , skip : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-|

  - where\_ -

-}
blogPosts : (BlogPostsOptionalArguments -> BlogPostsOptionalArguments) -> SelectionSet decodesTo DB.Object.BlogPost -> SelectionSet (List (Maybe decodesTo)) RootQuery
blogPosts fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ DB.InputObject.encodeBlogPostWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum DB.Enum.BlogPostOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "blogPosts" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


type alias ContactsOptionalArguments =
    { where_ : OptionalArgument DB.InputObject.ContactWhereInput
    , orderBy : OptionalArgument DB.Enum.ContactOrderByInput.ContactOrderByInput
    , skip : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-|

  - where\_ -

-}
contacts : (ContactsOptionalArguments -> ContactsOptionalArguments) -> SelectionSet decodesTo DB.Object.Contact -> SelectionSet (List (Maybe decodesTo)) RootQuery
contacts fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ DB.InputObject.encodeContactWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum DB.Enum.ContactOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "contacts" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


type alias ProjectsOptionalArguments =
    { where_ : OptionalArgument DB.InputObject.ProjectWhereInput
    , orderBy : OptionalArgument DB.Enum.ProjectOrderByInput.ProjectOrderByInput
    , skip : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-|

  - where\_ -

-}
projects : (ProjectsOptionalArguments -> ProjectsOptionalArguments) -> SelectionSet decodesTo DB.Object.Project -> SelectionSet (List (Maybe decodesTo)) RootQuery
projects fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ DB.InputObject.encodeProjectWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum DB.Enum.ProjectOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "projects" optionalArgs object_ (identity >> Decode.nullable >> Decode.list)


type alias AssetRequiredArguments =
    { where_ : DB.InputObject.AssetWhereUniqueInput }


asset : AssetRequiredArguments -> SelectionSet decodesTo DB.Object.Asset -> SelectionSet (Maybe decodesTo) RootQuery
asset requiredArgs object_ =
    Object.selectionForCompositeField "asset" [ Argument.required "where" requiredArgs.where_ DB.InputObject.encodeAssetWhereUniqueInput ] object_ (identity >> Decode.nullable)


type alias ColorRequiredArguments =
    { where_ : DB.InputObject.ColorWhereUniqueInput }


color : ColorRequiredArguments -> SelectionSet decodesTo DB.Object.Color -> SelectionSet (Maybe decodesTo) RootQuery
color requiredArgs object_ =
    Object.selectionForCompositeField "color" [ Argument.required "where" requiredArgs.where_ DB.InputObject.encodeColorWhereUniqueInput ] object_ (identity >> Decode.nullable)


type alias LocationRequiredArguments =
    { where_ : DB.InputObject.LocationWhereUniqueInput }


location : LocationRequiredArguments -> SelectionSet decodesTo DB.Object.Location -> SelectionSet (Maybe decodesTo) RootQuery
location requiredArgs object_ =
    Object.selectionForCompositeField "location" [ Argument.required "where" requiredArgs.where_ DB.InputObject.encodeLocationWhereUniqueInput ] object_ (identity >> Decode.nullable)


type alias BlogPostRequiredArguments =
    { where_ : DB.InputObject.BlogPostWhereUniqueInput }


blogPost : BlogPostRequiredArguments -> SelectionSet decodesTo DB.Object.BlogPost -> SelectionSet (Maybe decodesTo) RootQuery
blogPost requiredArgs object_ =
    Object.selectionForCompositeField "blogPost" [ Argument.required "where" requiredArgs.where_ DB.InputObject.encodeBlogPostWhereUniqueInput ] object_ (identity >> Decode.nullable)


type alias ContactRequiredArguments =
    { where_ : DB.InputObject.ContactWhereUniqueInput }


contact : ContactRequiredArguments -> SelectionSet decodesTo DB.Object.Contact -> SelectionSet (Maybe decodesTo) RootQuery
contact requiredArgs object_ =
    Object.selectionForCompositeField "contact" [ Argument.required "where" requiredArgs.where_ DB.InputObject.encodeContactWhereUniqueInput ] object_ (identity >> Decode.nullable)


type alias ProjectRequiredArguments =
    { where_ : DB.InputObject.ProjectWhereUniqueInput }


project : ProjectRequiredArguments -> SelectionSet decodesTo DB.Object.Project -> SelectionSet (Maybe decodesTo) RootQuery
project requiredArgs object_ =
    Object.selectionForCompositeField "project" [ Argument.required "where" requiredArgs.where_ DB.InputObject.encodeProjectWhereUniqueInput ] object_ (identity >> Decode.nullable)


type alias AssetsConnectionOptionalArguments =
    { where_ : OptionalArgument DB.InputObject.AssetWhereInput
    , orderBy : OptionalArgument DB.Enum.AssetOrderByInput.AssetOrderByInput
    , skip : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-|

  - where\_ -

-}
assetsConnection : (AssetsConnectionOptionalArguments -> AssetsConnectionOptionalArguments) -> SelectionSet decodesTo DB.Object.AssetConnection -> SelectionSet decodesTo RootQuery
assetsConnection fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ DB.InputObject.encodeAssetWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum DB.Enum.AssetOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "assetsConnection" optionalArgs object_ identity


type alias ColorsConnectionOptionalArguments =
    { where_ : OptionalArgument DB.InputObject.ColorWhereInput
    , orderBy : OptionalArgument DB.Enum.ColorOrderByInput.ColorOrderByInput
    , skip : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-|

  - where\_ -

-}
colorsConnection : (ColorsConnectionOptionalArguments -> ColorsConnectionOptionalArguments) -> SelectionSet decodesTo DB.Object.ColorConnection -> SelectionSet decodesTo RootQuery
colorsConnection fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ DB.InputObject.encodeColorWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum DB.Enum.ColorOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "colorsConnection" optionalArgs object_ identity


type alias LocationsConnectionOptionalArguments =
    { where_ : OptionalArgument DB.InputObject.LocationWhereInput
    , orderBy : OptionalArgument DB.Enum.LocationOrderByInput.LocationOrderByInput
    , skip : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-|

  - where\_ -

-}
locationsConnection : (LocationsConnectionOptionalArguments -> LocationsConnectionOptionalArguments) -> SelectionSet decodesTo DB.Object.LocationConnection -> SelectionSet decodesTo RootQuery
locationsConnection fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ DB.InputObject.encodeLocationWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum DB.Enum.LocationOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "locationsConnection" optionalArgs object_ identity


type alias BlogPostsConnectionOptionalArguments =
    { where_ : OptionalArgument DB.InputObject.BlogPostWhereInput
    , orderBy : OptionalArgument DB.Enum.BlogPostOrderByInput.BlogPostOrderByInput
    , skip : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-|

  - where\_ -

-}
blogPostsConnection : (BlogPostsConnectionOptionalArguments -> BlogPostsConnectionOptionalArguments) -> SelectionSet decodesTo DB.Object.BlogPostConnection -> SelectionSet decodesTo RootQuery
blogPostsConnection fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ DB.InputObject.encodeBlogPostWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum DB.Enum.BlogPostOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "blogPostsConnection" optionalArgs object_ identity


type alias ContactsConnectionOptionalArguments =
    { where_ : OptionalArgument DB.InputObject.ContactWhereInput
    , orderBy : OptionalArgument DB.Enum.ContactOrderByInput.ContactOrderByInput
    , skip : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-|

  - where\_ -

-}
contactsConnection : (ContactsConnectionOptionalArguments -> ContactsConnectionOptionalArguments) -> SelectionSet decodesTo DB.Object.ContactConnection -> SelectionSet decodesTo RootQuery
contactsConnection fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ DB.InputObject.encodeContactWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum DB.Enum.ContactOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "contactsConnection" optionalArgs object_ identity


type alias ProjectsConnectionOptionalArguments =
    { where_ : OptionalArgument DB.InputObject.ProjectWhereInput
    , orderBy : OptionalArgument DB.Enum.ProjectOrderByInput.ProjectOrderByInput
    , skip : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-|

  - where\_ -

-}
projectsConnection : (ProjectsConnectionOptionalArguments -> ProjectsConnectionOptionalArguments) -> SelectionSet decodesTo DB.Object.ProjectConnection -> SelectionSet decodesTo RootQuery
projectsConnection fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ DB.InputObject.encodeProjectWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum DB.Enum.ProjectOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "projectsConnection" optionalArgs object_ identity


type alias NodeRequiredArguments =
    { id : DB.ScalarDecoders.Id }


{-| Fetches an object given its ID

  - id - The ID of an object

-}
node : NodeRequiredArguments -> SelectionSet decodesTo DB.Interface.Node -> SelectionSet (Maybe decodesTo) RootQuery
node requiredArgs object_ =
    Object.selectionForCompositeField "node" [ Argument.required "id" requiredArgs.id (\(DB.Scalar.Id raw) -> Encode.string raw) ] object_ (identity >> Decode.nullable)
