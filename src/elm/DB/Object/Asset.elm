-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module DB.Object.Asset exposing (ImagesProjectsOptionalArguments, PictureBlogPostOptionalArguments, PictureProjectsOptionalArguments, UrlOptionalArguments, createdAt, fileName, handle, height, id, imagesProjects, mimeType, pictureBlogPost, pictureProjects, size, status, updatedAt, url, width)

import DB.Enum.BlogPostOrderByInput
import DB.Enum.ProjectsOrderByInput
import DB.Enum.Status
import DB.InputObject
import DB.Object
import DB.Scalar
import DB.ScalarDecoders
import Graphql.Internal.Builder.Argument as Argument
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


status : SelectionSet DB.Enum.Status.Status DB.Object.Asset
status =
    Object.selectionForField "Enum.Status.Status" "status" [] DB.Enum.Status.decoder


id : SelectionSet DB.ScalarDecoders.Id DB.Object.Asset
id =
    Object.selectionForField "ScalarDecoders.Id" "id" [] (DB.ScalarDecoders.decoders |> DB.Scalar.unwrapDecoders |> .decoderId)


createdAt : SelectionSet DB.ScalarDecoders.DateTime DB.Object.Asset
createdAt =
    Object.selectionForField "ScalarDecoders.DateTime" "createdAt" [] (DB.ScalarDecoders.decoders |> DB.Scalar.unwrapDecoders |> .decoderDateTime)


updatedAt : SelectionSet DB.ScalarDecoders.DateTime DB.Object.Asset
updatedAt =
    Object.selectionForField "ScalarDecoders.DateTime" "updatedAt" [] (DB.ScalarDecoders.decoders |> DB.Scalar.unwrapDecoders |> .decoderDateTime)


handle : SelectionSet String DB.Object.Asset
handle =
    Object.selectionForField "String" "handle" [] Decode.string


fileName : SelectionSet String DB.Object.Asset
fileName =
    Object.selectionForField "String" "fileName" [] Decode.string


height : SelectionSet (Maybe Float) DB.Object.Asset
height =
    Object.selectionForField "(Maybe Float)" "height" [] (Decode.float |> Decode.nullable)


mimeType : SelectionSet (Maybe String) DB.Object.Asset
mimeType =
    Object.selectionForField "(Maybe String)" "mimeType" [] (Decode.string |> Decode.nullable)


size : SelectionSet (Maybe Float) DB.Object.Asset
size =
    Object.selectionForField "(Maybe Float)" "size" [] (Decode.float |> Decode.nullable)


width : SelectionSet (Maybe Float) DB.Object.Asset
width =
    Object.selectionForField "(Maybe Float)" "width" [] (Decode.float |> Decode.nullable)


type alias PictureBlogPostOptionalArguments =
    { where_ : OptionalArgument DB.InputObject.BlogPostWhereInput
    , orderBy : OptionalArgument DB.Enum.BlogPostOrderByInput.BlogPostOrderByInput
    , skip : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-|

  - where\_ -

-}
pictureBlogPost : (PictureBlogPostOptionalArguments -> PictureBlogPostOptionalArguments) -> SelectionSet decodesTo DB.Object.BlogPost -> SelectionSet (Maybe (List decodesTo)) DB.Object.Asset
pictureBlogPost fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ DB.InputObject.encodeBlogPostWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum DB.Enum.BlogPostOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "pictureBlogPost" optionalArgs object_ (identity >> Decode.list >> Decode.nullable)


type alias ImagesProjectsOptionalArguments =
    { where_ : OptionalArgument DB.InputObject.ProjectsWhereInput
    , orderBy : OptionalArgument DB.Enum.ProjectsOrderByInput.ProjectsOrderByInput
    , skip : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-|

  - where\_ -

-}
imagesProjects : (ImagesProjectsOptionalArguments -> ImagesProjectsOptionalArguments) -> SelectionSet decodesTo DB.Object.Projects -> SelectionSet (Maybe (List decodesTo)) DB.Object.Asset
imagesProjects fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ DB.InputObject.encodeProjectsWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum DB.Enum.ProjectsOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "imagesProjects" optionalArgs object_ (identity >> Decode.list >> Decode.nullable)


type alias PictureProjectsOptionalArguments =
    { where_ : OptionalArgument DB.InputObject.ProjectsWhereInput
    , orderBy : OptionalArgument DB.Enum.ProjectsOrderByInput.ProjectsOrderByInput
    , skip : OptionalArgument Int
    , after : OptionalArgument String
    , before : OptionalArgument String
    , first : OptionalArgument Int
    , last : OptionalArgument Int
    }


{-|

  - where\_ -

-}
pictureProjects : (PictureProjectsOptionalArguments -> PictureProjectsOptionalArguments) -> SelectionSet decodesTo DB.Object.Projects -> SelectionSet (Maybe (List decodesTo)) DB.Object.Asset
pictureProjects fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { where_ = Absent, orderBy = Absent, skip = Absent, after = Absent, before = Absent, first = Absent, last = Absent }

        optionalArgs =
            [ Argument.optional "where" filledInOptionals.where_ DB.InputObject.encodeProjectsWhereInput, Argument.optional "orderBy" filledInOptionals.orderBy (Encode.enum DB.Enum.ProjectsOrderByInput.toString), Argument.optional "skip" filledInOptionals.skip Encode.int, Argument.optional "after" filledInOptionals.after Encode.string, Argument.optional "before" filledInOptionals.before Encode.string, Argument.optional "first" filledInOptionals.first Encode.int, Argument.optional "last" filledInOptionals.last Encode.int ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "pictureProjects" optionalArgs object_ (identity >> Decode.list >> Decode.nullable)


type alias UrlOptionalArguments =
    { transformation : OptionalArgument DB.InputObject.AssetTransformationInput }


{-| Get the url for the asset with provided transformations applied.
-}
url : (UrlOptionalArguments -> UrlOptionalArguments) -> SelectionSet String DB.Object.Asset
url fillInOptionals =
    let
        filledInOptionals =
            fillInOptionals { transformation = Absent }

        optionalArgs =
            [ Argument.optional "transformation" filledInOptionals.transformation DB.InputObject.encodeAssetTransformationInput ]
                |> List.filterMap identity
    in
    Object.selectionForField "String" "url" optionalArgs Decode.string
